this was 28122025, add the updated skripts, post to chatGPT and procede with stripe integration





user/registration/pricing/_index.md:

<div id="checkout-status">Starting checkout‚Ä¶</div>

<script>
(async () => {
  // 1. Wait until auth is initialized
  while (!window.auth || !window.auth.initialized) {
    await new Promise(r => setTimeout(r, 50));
  }

  // 2. Get current session
  const { data: sessionData } = await window.supabaseClient.auth.getSession();
  const session = sessionData?.session;

  if (!session) {
    document.getElementById('checkout-status').textContent =
      'You must be logged in to continue.';
    return;
  }

  // 3. Read price_id from URL
  const params = new URLSearchParams(window.location.search);
  const priceId = params.get('price');

  if (!priceId) {
    document.getElementById('checkout-status').textContent =
      'Missing price information.';
    return;
  }

  // 4. Call Supabase Edge Function
  const res = await fetch('/functions/v1/create-checkout', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${session.access_token}`
    },
    body: JSON.stringify({ priceId })
  });

  if (!res.ok) {
    const txt = await res.text();
    document.getElementById('checkout-status').textContent =
      'Checkout error: ' + txt;
    return;
  }

  // 5. Redirect to Stripe Checkout
  const { url } = await res.json();
  window.location.href = url;
})();
</script>


<a href="/BiochemProtocols/user/registration/checkout/?price=price_1AAA111">
  Buy Explore
</a>

<a href="/BiochemProtocols/user/registration/checkout/?price=price_1AAA222">
  Buy Explore (Yearly)
</a>


content_head_example:
+++
required_plan = 'Execute,Document,Optimise,Admin'
+++

layouts/partials/navigation.html:
<nav class="navigation">
    <a href="{{ "" | relURL }}"><img class="logo" src="{{ "images/3biochem_white.png" | relURL }}" alt="Logo"></a>
    <ul class="navigation">
        <li class="navigation"><a href="{{ "" | relURL }}">{{"Home"}}</a></li>
        <li class="navigation"><a href="{{ "recipes" | relURL }}">{{"Recipes"}}</a></li>
        <li class="navigation"><a href="{{ "methods" | relURL }}">{{"Methods"}}</a></li>
        <li class="navigation"><a href="{{ "workflows" | relURL }}">{{"Workflows"}}</a></li>
        <li class="navigation"><a href="{{ "labjournal" | relURL }}">{{"Labjournal"}}</a></li>
        <li class="navigation"><a href="{{ "user/registration/pricing/" | relURL }}">{{"Pricing"}}</a></li>
        <li class="navigation"><button class="btn_login">Login</button></li>
    </ul>
</nav>

layouts/partials/login.html:
<div class="login_overlay"></div>
<div class="wrapper_login">
    <span class="icon_close"><ion-icon name="close"></ion-icon></span>
    <div class="login_register_forms">    
        <div class="login_form">
            <h2>Login</h2>
            <form action="#">
                <div class="input_box">
                    <span class="icon"><ion-icon name="mail"></ion-icon></span>
                    <input type="email" required>
                    <label>Email</label>
                </div>
                <div class="input_box">
                    <span class="icon"><ion-icon name="lock-closed"></ion-icon></span>
                    <input type="password" required>
                    <label>Password</label>
                </div>
                <div class="remember_forgot">
                    <label><input type="checkbox">Remember me</label>
                    <a href="#">Forgot Password?</a>
                </div>
                <button type="submit" class="btn_login_form">Login</button>
                <div class="login_register">
                    <p>Don't have an account? <a href="#" class="register_link">Register</a></p>
                </div>
            </form>
        </div>
        <div class="registration_form">
            <h2>Registration</h2>
            <form action="#">
                <div class="registration_form_names">
                    <div class="input_box">
                        <span class="icon"><ion-icon name="person"></ion-icon></span>
                        <input type="text" name="first_name" required>
                        <label>First Name(s)</label>
                    </div>
                    <div class="input_box">
                        <span class="icon"><ion-icon name="person"></ion-icon></span>
                        <input type="text" name="last_name" required>
                        <label>Last Name</label>
                    </div>
                </div>
                <div class="input_box">
                    <span class="icon"><ion-icon name="mail"></ion-icon></span>
                    <input type="email" required>
                    <label>Email</label>
                </div>
                <div class="input_box">
                    <span class="icon"><ion-icon name="lock-closed"></ion-icon></span>
                    <input type="password" required>
                    <label>Password</label>
                </div>
                <div class="remember_forgot">
                    <label><input type="checkbox">Agree to the Terms of Use</label>
                </div>
                <button type="submit" class="btn_login_form">Register</button>
                <div class="login_register">
                    <p>Already have an account? <a href="#" class="login_link">Login</a></p>
                </div>
            </form>
        </div>
    </div>
</div>
<script src="{{ "js/user/login.js" | relURL }}"></script>
<script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
<script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>

layouts/shortcodes/stripe_pricing_table.html:
<script async src="https://js.stripe.com/v3/pricing-table.js"></script>
<stripe-pricing-table pricing-table-id="prctbl_1SjHvIRrC5pt0KcWtYJ6N3Uy"
publishable-key="pk_test_51Sj7psRrC5pt0KcWOQZKSR7RvzxcDmA5zGfIJ53qRSStYrzl29AeeVD2RcqjtD2fgcKyDyWfFiIiqh8UzAikn2Bp00oMEveWeC">
</stripe-pricing-table>

<script async src="https://js.stripe.com/v3/pricing-table.js"></script>
<stripe-pricing-table pricing-table-id="prctbl_1SjLiYRrC5pt0KcWvQ62AW9M"
publishable-key="pk_test_51Sj7psRrC5pt0KcWOQZKSR7RvzxcDmA5zGfIJ53qRSStYrzl29AeeVD2RcqjtD2fgcKyDyWfFiIiqh8UzAikn2Bp00oMEveWeC">
</stripe-pricing-table>

baesof.html:
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ "css/styles.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/navigation.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/login.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/header.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/buttons.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/dropdowns.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/calc_bacterial_growth.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/table_sds-page_gels.css" | relURL }}">
    <link rel="stylesheet" href="{{ "css/footer.css" | relURL }}">
    <!-- math -->
    {{ if .Params.math }}
      {{ partial "math.html" . }}
    {{ end }}
    <!-- math -->
    <title>Document</title>
</head>
<body data-required-plan="{{ .Params.required_plan }}">
    {{ partial "navigation" . }}
    {{ partial "login" . }}
    {{ partial "header" . }}
    <main>
            {{block "main" . }}
            {{end}}
    </main>
    {{ partial "footer" . }}
<!-- Supabase initialization -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
  window.supabaseClient = supabase.createClient(
    'https://hkcytxqlswwcfwegpjnf.supabase.co',
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhrY3l0eHFsc3d3Y2Z3ZWdwam5mIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4Mjg2NjIsImV4cCI6MjA4MjQwNDY2Mn0.EPVpZ-1HaM3jhN87FXpJyCP7mmOEzS7zy-HQNZlytF0'
  );
</script>
<!-- Supabase initialization -->
<!-- authentication -->
<script src="{{ "js/user/auth.js" | relURL }}"></script>
<!-- authentication -->
<!-- subscription -->
<script src="{{ "js/user/subscription.js" | relURL }}"></script>
<!-- subscription -->
<!-- subscription -->
<script src="{{ "js/user/guard.js" | relURL }}"></script>
<!-- subscription -->
<!-- access code -->
<script>
  window.ACCESS_CODES = {{ .Site.Data.access.passwords | jsonify | safeJS }};
</script>
<script src="{{ "js/user/access.js" | relURL }}"></script>
<!-- access code -->
<!-- scripts -->
<script src="{{ "js/theme_toggle.js" | relURL }}"></script>
<script src="{{ "js/calculators/age_buffer_select.js" | relURL }}"></script>
<script src="{{ "js/calculators/age_mastermix_prep_calc.js" | relURL }}"></script>
<script src="{{ "js/calculators/age_sample_prep_calc.js" | relURL }}"></script>
<script src="{{ "js/calculators/pcr_mastermix_prep_calc.js" | relURL }}"></script>
<script src="{{ "js/calculators/age_following_pcr_buffer.js" | relURL }}"></script>
<script src="{{ "js/timer.js" | relURL }}"></script>
<script src="{{ "js/calculators/transformation_from_pcr_mastermix_prep_calc.js" | relURL }}"></script>
<script src="{{ "js/alternative_switches/primer_alternative.js" | relURL }}"></script>
<script src="{{ "js/alternative_switches/alt_methods.js" | relURL }}"></script> <!-- baseof is correct -->
<script src="{{ "js/calculators/calc_recipe_x.js" | relURL }}"></script> <!-- baseof is correct -->
<script src="{{ "js/calculators/calc_recipe_vol.js" | relURL }}"></script> <!-- baseof is correct -->
<script src="{{ "js/calculators/calc_recipe_mol.js" | relURL }}"></script> <!-- baseof is correct -->
<script src="{{ "js/calculators/calc_recipe_amount.js" | relURL }}"></script> <!-- baseof is correct -->
<script src="{{ "js/comment_box.js" | relURL }}"></script>
<script src="{{ "js/save_page.js" | relURL }}"></script>
{{ if .Page.HasShortcode "table_sds-page_gels" }}
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script src="{{ "js/table_sds-page_gels.js" | relURL }}"></script>
{{ end }
{{ if .Page.HasShortcode "calculators/calc_bacterial_growth" }}
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>  <!-- save as excel -->
  <script src="{{ "js/calculators/calc_bacterial_growth.js" | relURL }}"></script>
{{ end }}
{{ if .Page.HasShortcode "calculators/display_current_time" }}
<script src="{{ "js/calculators/display_current_time.js" | relURL }}"></script>
{{ end }}
<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script> <!-- generate QR -->
<script src="{{ "js/save_journal_label.js" | relURL }}"></script>
<!-- scripts -->
</body>
</html>

static/js/user/auth.js:
// Expose a single global object
window.auth = {
  user: null,
  session: null,
  initialized: false
};
// Initialize auth state ONCE
async function initAuth() {
  const { data, error } = await supabaseClient.auth.getSession();
  if (error) {
    console.error('Auth init error:', error);
    window.auth.initialized = true;
    return;
  }
  window.auth.session = data.session || null;
  window.auth.user = data.session?.user || null;
  window.auth.initialized = true;
}
// Keep auth state in sync
supabaseClient.auth.onAuthStateChange((_event, session) => {
  window.auth.session = session;
  window.auth.user = session?.user || null;
});
// Helper: always returns current user
async function getCurrentUser() {
  if (window.auth.initialized) {
    return window.auth.user;
  }
  const { data } = await supabaseClient.auth.getSession();
  return data.session?.user || null;
}
// Soft guard
async function requireAuth(redirectTo = '/login/') {
  const user = await getCurrentUser();
  if (!user) {
    window.location.href = redirectTo;
    return null;
  }
  return user;
}
// Logout
async function logout() {
  await supabaseClient.auth.signOut();
  window.location.reload();
}
// Expose helpers
window.getCurrentUser = getCurrentUser;
window.requireAuth = requireAuth;
window.logout = logout;
document.addEventListener('DOMContentLoaded', async () => {
  await initAuth();
  const btn = document.querySelector('.btn_login');
  if (btn && window.auth.user) {
    btn.textContent = 'Logout';
    btn.onclick = logout;
  }
});
document.addEventListener('auth:login', async () => {
  const user = await getCurrentUser();
  console.log('User after login:', user);
  // Example: change Login button to Logout
  const btn = document.querySelector('.btn_login');
  if (btn && user) {
    btn.textContent = 'Logout';
    btn.onclick = logout;
  }
});



static/js/user/guard.js:
document.addEventListener('DOMContentLoaded', async () => {
  await window.subscriptionReady;
  const requiredAttr = document.body.dataset.requiredPlan;
  if (!requiredAttr) return;
  const allowedPlans = requiredAttr
    .split(',')
    .map(p => p.trim());
  if (!allowedPlans.includes(window.subscription.plan)) {
    window.location.replace('/BiochemProtocols/user/registration/pricing/');
  }
});


static/js/user/login.js:// JS_STREAMLINE
// JS_COMMENTS

const wrapper_login = document.querySelector('.wrapper_login');
const login_link = document.querySelector('.login_link');
const register_link = document.querySelector('.register_link');
const btn_login = document.querySelector('.btn_login');
const icon_close = document.querySelector('.icon_close');
const login_overlay = document.querySelector('.login_overlay');

register_link.addEventListener('click', ()=> {
    wrapper_login.classList.add('active');
});

login_link.addEventListener('click', ()=> {
    wrapper_login.classList.remove('active');
});

// CHANGED281225
btn_login.addEventListener('click', (e) => {
  e.preventDefault();
  if (btn_login.dataset.state === 'logged-in') {
    logout();
    return;
  }
  wrapper_login.classList.add('active_popup');
  login_overlay.classList.add('active');
  document.body.style.overflow = 'hidden';
});
// CHANGED281225

icon_close.addEventListener('click', ()=> {
    wrapper_login.classList.remove('active_popup');
    login_overlay.classList.remove('active');
    document.body.style.overflow = '';
});

login_overlay.addEventListener('click', () => {
    wrapper_login.classList.remove('active_popup');
    login_overlay.classList.remove('active');
    document.body.style.overflow = '';
});

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && wrapper_login.classList.contains('active_popup')) {
        wrapper_login.classList.remove('active_popup');
        login_overlay.classList.remove('active');
        document.body.style.overflow = '';
    }
});

////////// JS_DONE: up to here //////////

// LOGIN an Supabase anbinden //
const loginForm = document.querySelector('.login_form form');

if (loginForm) {
  loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    const email = loginForm.querySelector('input[type="email"]').value;
    const password = loginForm.querySelector('input[type="password"]').value;

    const { data, error } = await supabaseClient.auth.signInWithPassword({
      email,
      password
    });

    if (error) {
      console.error('LOGIN ERROR:', error);
      alert(error.message);
      return;
    }

    console.log('LOGIN OK:', data);

    // ‚úÖ Close login modal
    wrapper_login.classList.remove('active_popup');
    login_overlay.classList.remove('active');
    document.body.style.overflow = '';
  });
}


// Registrierung anbinden //
const registerForm = document.querySelector('.registration_form form');

if (registerForm) {
  registerForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    const firstName = registerForm.querySelector('input[name="first_name"]').value;
    const lastName  = registerForm.querySelector('input[name="last_name"]').value;
    const email     = registerForm.querySelector('input[type="email"]').value;
    const password  = registerForm.querySelector('input[type="password"]').value;

    const { data, error } = await supabaseClient.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo:
          'https://spikemurphy.github.io/BiochemProtocols/user/registration/callback',
        data: {
          first_name: firstName,
          last_name: lastName,
          accepted_terms: true,
          accepted_terms_at: new Date().toISOString()
        }
      }
    });

    if (error) {
      alert(error.message);
      return;
    }

    alert('Confirm your mail address, please.');
  });
}

// registration callback callback //
(async () => {
  const hash = window.location.hash;

  if (!hash || !hash.includes('access_token')) return;

  const { data, error } = await supabaseClient.auth.getSession();

  if (error) {
    console.error('Session error:', error);
    return;
  }

  if (data?.session) {
    console.log('Signup / Magiclink callback detected');

    // Tokens aus der URL entfernen (DSGVO!)
    window.history.replaceState(
      {},
      document.title,
      '/BiochemProtocols/'
    );

    // Weiterleitung
    window.location.href =
      '/BiochemProtocols/user/registration/callback/';
  }
})();


static/user/subscription.js
// js/user/subscription.js
// ------------------------------------
// Runtime subscription state (Supabase)
// ------------------------------------

window.subscription = {
  plan: 'free',
  status: null,
  loaded: false
};

/**
 * Load the current user's subscription from Supabase
 */
async function loadSubscription() {
  const user = await getCurrentUser();

  if (!user) {
    window.subscription.loaded = true;
    return;
  }

  // Admin override
  if (user.app_metadata?.role === 'admin') {
    window.subscription.plan = 'Admin';
    window.subscription.status = 'active';
    window.subscription.loaded = true;
    return;
  }

  const { data, error } = await supabaseClient
    .from('subscriptions')
    .select('plan, status')
    .eq('user_id', user.id)
    .single();

  if (error || !data) {
    window.subscription.loaded = true;
    return;
  }

  window.subscription.plan = data.plan;
  window.subscription.status = data.status;
  window.subscription.loaded = true;
}

// Expose loader
window.loadSubscription = loadSubscription;

// ------------------------------------
// Ready promise (prevents race bugs)
// ------------------------------------

window.subscriptionReady = (async () => {
  try {
    await loadSubscription();
  } catch (err) {
    console.error('Failed to load subscription:', err);
    window.subscription.loaded = true;
  }
})();




supabase/create-checkout/index.ts
import { serve } from "https://deno.land/std/http/server.ts";
import Stripe from "https://esm.sh/stripe@14.21.0";

const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, {
  apiVersion: "2023-10-16",
});

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, content-type",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
};

serve(async (req) => {
  // ‚úÖ Handle CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    if (req.method !== "POST") {
      return new Response("Method not allowed", {
        status: 405,
        headers: corsHeaders,
      });
    }

    const authHeader = req.headers.get("Authorization");
    if (!authHeader) {
      return new Response("Unauthorized", {
        status: 401,
        headers: corsHeaders,
      });
    }

    const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
    const supabaseKey = Deno.env.get("SERVICE_ROLE_KEY")!;
    const { createClient } = await import("https://esm.sh/@supabase/supabase-js@2");

    const supabase = createClient(supabaseUrl, supabaseKey);

    const token = authHeader.replace("Bearer ", "");
    const {
      data: { user },
      error,
    } = await supabase.auth.getUser(token);

    if (error || !user) {
      return new Response("Invalid user", {
        status: 401,
        headers: corsHeaders,
      });
    }

    const { priceId } = await req.json();
    if (!priceId) {
      return new Response("Missing priceId", {
        status: 400,
        headers: corsHeaders,
      });
    }

    const { data: profile } = await supabase
      .from("profiles")
      .select("stripe_customer_id")
      .eq("id", user.id)
      .single();

    let customerId = profile?.stripe_customer_id;

    if (!customerId) {
      const customer = await stripe.customers.create({
        email: user.email!,
        metadata: { supabase_user_id: user.id },
      });

      customerId = customer.id;

      await supabase
        .from("profiles")
        .update({ stripe_customer_id: customerId })
        .eq("id", user.id);
    }

    const session = await stripe.checkout.sessions.create({
      mode: "subscription",
      customer: customerId,
      line_items: [{ price: priceId, quantity: 1 }],
      success_url:
        "https://spikemurphy.github.io/BiochemProtocols/user/registration/success",
      cancel_url:
        "https://spikemurphy.github.io/BiochemProtocols/user/registration/pricing",
    });

    return new Response(JSON.stringify({ url: session.url }), {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json",
      },
    });
  } catch (err) {
    console.error(err);
    return new Response("Checkout error", {
      status: 500,
      headers: corsHeaders,
    });
  }
});



supabase/stripe-webhook/index.ts
import { serve } from "https://deno.land/std/http/server.ts";
import Stripe from "https://esm.sh/stripe@14.21.0";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const stripe = new Stripe(Deno.env.get("STRIPE_SECRET_KEY")!, {
  apiVersion: "2023-10-16",
});

serve(async (req) => {
  try {
    const signature = req.headers.get("stripe-signature");

    // Stripe sends no signature for test pings sometimes
    if (!signature) {
      console.warn("‚ö†Ô∏è Missing stripe-signature header");
      return new Response("ok", { status: 200 });
    }

    const body = await req.text();
    let event: Stripe.Event;

    try {
      event = stripe.webhooks.constructEvent(
        body,
        signature,
        Deno.env.get("STRIPE_WEBHOOK_SECRET")!
      );
    } catch (err) {
      console.error("‚ùå Invalid webhook signature", err);
      return new Response("ok", { status: 200 });
    }

    const supabase = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SERVICE_ROLE_KEY")!
    );

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       Idempotency protection
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    const eventId = event.id;

    const { data: existingEvent } = await supabase
      .from("stripe_events")
      .select("id")
      .eq("id", eventId)
      .maybeSingle();

    if (existingEvent) {
      console.log("‚è≠Ô∏è Event already processed:", eventId);
      return new Response("ok", { status: 200 });
    }

    await supabase.from("stripe_events").insert({ id: eventId });

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       Checkout completed
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    if (event.type === "checkout.session.completed") {
      const session = event.data.object as Stripe.Checkout.Session;

      const email = session.customer_details?.email;
      const customerId = session.customer as string;
      const subscriptionId = session.subscription as string;

      console.log("üìß Email:", email);
      console.log("üë§ Customer:", customerId);
      console.log("üîÅ Subscription:", subscriptionId);

      if (!email || !customerId || !subscriptionId) {
        console.warn("‚ö†Ô∏è Missing checkout data");
        return new Response("ok", { status: 200 });
      }

      /* Find user profile by email */
      const { data: profile, error: profileError } = await supabase
        .from("profiles")
        .select("id")
        .eq("email", email)
        .maybeSingle();

      if (profileError || !profile) {
        console.warn("‚ö†Ô∏è No profile found for:", email);
        return new Response("ok", { status: 200 });
      }

      /* Retrieve subscription from Stripe */
      const subscription = await stripe.subscriptions.retrieve(
        subscriptionId
      );

      /* Update profile */
      await supabase
        .from("profiles")
        .update({ stripe_customer_id: customerId })
        .eq("id", profile.id);

      /* Upsert subscription */
      await supabase.from("subscriptions").upsert({
        user_id: profile.id,
        stripe_customer_id: customerId,
        stripe_subscription_id: subscription.id,
        status: subscription.status,
        current_period_end: new Date(
          subscription.current_period_end * 1000
        ).toISOString(),
      });

      console.log("‚úÖ Subscription synced for", email);
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       Subscription updates / cancel
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

    if (
      event.type === "customer.subscription.updated" ||
      event.type === "customer.subscription.deleted"
    ) {
      const subscription = event.data.object as Stripe.Subscription;

      await supabase
        .from("subscriptions")
        .update({
          status: subscription.status,
          current_period_end: new Date(
            subscription.current_period_end * 1000
          ).toISOString(),
        })
        .eq("stripe_subscription_id", subscription.id);

      console.log("üîÑ Subscription updated:", subscription.id);
    }

    return new Response("ok", { status: 200 });
  } catch (err) {
    console.error("üî• Unhandled webhook error", err);
    return new Response("ok", { status: 200 });
  }
});



supabase/functions/config.toml:
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "BiochemProtocols"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

# Allow connections via S3 compatible clients
[storage.s3_protocol]
enabled = true

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Store analytical data in S3 for running ETL jobs over Iceberg Catalog
# This feature is only available on the hosted platform.
[storage.analytics]
enabled = false
max_namespaces = 5
max_tables = 10
max_catalogs = 2

# Analytics Buckets is available to Supabase Pro plan.
# [storage.analytics.buckets.my-warehouse]

# Store vector embeddings in S3 for large and durable datasets
# This feature is only available on the hosted platform.
[storage.vector]
enabled = false
max_buckets = 10
max_indexes = 5

# Vector Buckets is available to Supabase Pro plan.
# [storage.vector.buckets.documents-openai]

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# JWT issuer URL. If not set, defaults to the local API URL (http://127.0.0.1:<port>/auth/v1).
# jwt_issuer = ""
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

# Uncomment to customize notification email template
# [auth.email.notification.password_changed]
# enabled = true
# subject = "Your password has been changed"
# content_path = "./templates/password_changed_notification.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) ‚Äî enables hot reload during local development.
# `oneshot` ‚Äî fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

[functions.create-checkout]
enabled = true
verify_jwt = true
import_map = "./functions/create-checkout/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
entrypoint = "./functions/create-checkout/index.ts"
# Specifies static files to be bundled with the function. Supports glob patterns.
# For example, if you want to serve static HTML pages in your function:
# static_files = [ "./functions/create-checkout/*.html" ]

[functions.stripe-webhook]
enabled = true
verify_jwt = false
import_map = "./functions/stripe-webhook/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
entrypoint = "./functions/stripe-webhook/index.ts"
# Specifies static files to be bundled with the function. Supports glob patterns.
# For example, if you want to serve static HTML pages in your function:
# static_files = [ "./functions/stripe-webhook/*.html" ]
